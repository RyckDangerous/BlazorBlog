# R√®gles de d√©veloppement MarioShows

## üèóÔ∏è Architecture

### Vertical Slice Architecture
- **TOUJOURS** suivre la Vertical Slice Architecture
- Structure obligatoire : `Features/{Feature}/{Components,Services,Models,Repository,Configurations}`
- Chaque feature est autonome et contient tout ce dont elle a besoin
- Il peut y avoir un dossier "Shared" pour de vrais utilitaires partag√©s. Si un mod√®le devient commun √† l'application, il faut le mettre dans "Core/Models", car utilis√© dans beaucoup de Feature.

### S√©paration des responsabilit√©s
- **AUCUNE logique m√©tier dans les vues (.razor)**
- Toute la logique doit √™tre dans le code-behind (.razor.cs) ou dans les services
- Les vues ne font que de l'affichage et d√©l√®guent tout au code-behind
- Le code-behind d√©l√®gue la logique m√©tier aux services

### Services et couches
- Services m√©tier : contiennent la logique applicative
- Services de vue (ViewService) : g√®rent l'√©tat et la logique de pr√©sentation
- Repositories : acc√®s aux donn√©es uniquement
- Pas de logique m√©tier dans les repositories

## üìù Standards de code C#

### Classes et Records
- **Toutes les classes et records doivent √™tre `sealed` par d√©faut**
- Utiliser `record` pour les mod√®les immuables (DTOs, ViewModels, etc.)
- Utiliser `class` pour les services et repositories
- N'enlever `sealed` QUE si l'h√©ritage est explicitement n√©cessaire

```csharp
// ‚úÖ BON
public sealed record UserViewModel { ... }
public sealed class UserService { ... }

// ‚ùå MAUVAIS
public record UserViewModel { ... }
public class UserService { ... }
```

### Comparaisons et tests de nullit√©
- **TOUJOURS** utiliser `is` ou `is not` pour les comparaisons d'enum et les tests de nullit√©
- Plus d'intention et de lisibilit√© qu'avec `==` ou `!=`

```csharp
// ‚úÖ BON - Tests de nullit√©
if (myVariable is null) { ... }
if (myVariable is not null) { ... }

// ‚úÖ BON - Comparaisons d'enum
if (status is FavoriteStatus.AVoir) { ... }
if (priority is not FavoritePriority.Haute) { ... }

// ‚ùå MAUVAIS
if (myVariable == null) { ... }
if (myVariable != null) { ... }
if (status == FavoriteStatus.AVoir) { ... }
```

### Documentation
- **TOUJOURS** documenter les m√©thodes publiques avec des XML comments (`///`)
- Documenter les propri√©t√©s publiques des mod√®les
- Utiliser `<summary>`, `<param>`, `<returns>`, `<exception>` selon le besoin
- Ajouter des commentaires inline pour la logique complexe

```csharp
/// <summary>
/// Charge les favoris de l'utilisateur connect√©.
/// </summary>
/// <returns>Une liste de favoris.</returns>
/// <exception cref="UnauthorizedException">Si l'utilisateur n'est pas authentifi√©.</exception>
public async Task<List<Favorite>> LoadFavoritesAsync() { ... }
```

### Injection de d√©pendances
- **TOUJOURS** utiliser l'injection de d√©pendances pour les services
- Enregistrer les services dans les fichiers `Configurations/{Feature}Configuration.cs`
- Utiliser `services.AddScoped<T>()` pour les services avec √©tat de requ√™te
- Utiliser `services.AddTransient<T>()` pour les services sans √©tat

### Logging
- Logger toutes les actions importantes (d√©but, succ√®s, erreur)
- Utiliser `ILogger<T>` inject√©
- Niveaux : `LogInformation`, `LogWarning`, `LogError`, `LogDebug`

```csharp
_logger.LogInformation("Chargement des favoris pour l'utilisateur {UserId}", userId);
_logger.LogError(ex, "Erreur lors du chargement des favoris");
```

## üé® Composants Blazor

### Composants autonomes
- Les composants doivent √™tre **autonomes** et fonctionner uniquement avec des param√®tres
- **AUCUN acc√®s direct aux services** dans les composants enfants
- Toutes les donn√©es n√©cessaires doivent √™tre pass√©es via `[Parameter]`
- Communication parent-enfant via `EventCallback<T>`

```csharp
// ‚úÖ BON - Composant autonome
[Parameter]
public Favorite Favorite { get; set; } = default!;

[Parameter]
public EventCallback<Favorite> OnRemove { get; set; }

// ‚ùå MAUVAIS - Acc√®s direct √† un service
[Inject]
private IFavoriteService FavoriteService { get; set; }
```

### Structure des composants
- `{Component}.razor` : markup uniquement
- `{Component}.razor.cs` : code-behind avec toute la logique
- `{Component}.razor.css` : styles scoped au composant
- Ajouter un `README.md` pour les composants complexes ou r√©utilisables

### Styles
- **TOUJOURS** utiliser des styles scoped (`.razor.css`)
- Ne pas utiliser de styles inline sauf exception justifi√©e
- Utiliser Bootstrap pour la structure, styles custom pour les d√©tails

## üéØ Conventions de nommage

### Suffixes obligatoires
- Services m√©tier : `{Feature}Service` (ex: `FavoriteService`)
- Services de vue : `{Feature}ViewService` (ex: `FavoritesViewService`)
- Repositories : `{Entity}Repository` (ex: `FavoriteRepository`)
- ViewModels : `{Feature}ViewModel` (ex: `FavoritesViewModel`)
- Configurations DI : `{Feature}Configuration` (ex: `FavoritesConfiguration`)

### Interfaces
- Pr√©fixe `I` pour toutes les interfaces (ex: `IFavoriteService`)
- Une interface par service pour faciliter les tests

### Fichiers et dossiers
- PascalCase pour tous les noms de fichiers
- Dossiers : `Components`, `Services`, `Models`, `Repository`, `Configurations`
- Pages : suffixe `Page` (ex: `FavoritesPage.razor`)

## üß™ Tests et qualit√©

### Tests unitaires
- √âcrire des tests unitaires pour toute la logique m√©tier
- Les services doivent √™tre testables (injection de d√©pendances)
- Mocker les d√©pendances avec des interfaces

### Gestion des erreurs
- **TOUJOURS** utiliser le pattern `ResultOf<T>` pour les retours de m√©thodes des services
- Les m√©thodes doivent retourner `ResultOf<T>` ou `ResultOf` (sans valeur)
- Utiliser `ResultOf.Success(value)` pour les succ√®s et `ResultOf.Failure(error)` pour les erreurs
- Cr√©er des classes d'erreur sp√©cifiques h√©ritant de `Error` (ex: `NotFoundError`, `ValidationError`, etc.)
- Logger les erreurs dans les services avant de retourner un `ResultOf.Failure`
- Dans les code-behind, v√©rifier `result.HasError` et afficher les messages via Snackbar

```csharp
// ‚úÖ BON - Dans un service
public async Task<ResultOf<User>> GetUserAsync(string userId)
{
    try
    {
        var user = await _repository.FindByIdAsync(userId);
        if (user is null)
        {
            _logger.LogWarning("Utilisateur {UserId} introuvable", userId);
            return ResultOf.Failure<User>(new NotFoundError($"Utilisateur {userId} introuvable"));
        }
        return ResultOf.Success(user);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Erreur lors de la r√©cup√©ration de l'utilisateur {UserId}", userId);
        return ResultOf.Failure<User>(new Error("Erreur lors de la r√©cup√©ration de l'utilisateur", ex));
    }
}

// ‚úÖ BON - Dans un code-behind
var result = await _userService.GetUserAsync(userId);
if (result.HasError)
{
    _logger.LogError("Erreur: {Message}", result.Error?.Message);
    _snackbar.ShowError(result.Error?.Message ?? "Une erreur est survenue.");
    return;
}
var user = result.Value;
_snackbar.ShowSuccess("Utilisateur charg√© avec succ√®s !");
```

```csharp
// ‚ùå MAUVAIS - Utiliser des exceptions pour le flux normal
public async Task<User> GetUserAsync(string userId)
{
    var user = await _repository.FindByIdAsync(userId);
    if (user is null)
    {
        throw new NotFoundException("Utilisateur introuvable");
    }
    return user;
}
```

## üöÄ Bonnes pratiques sp√©cifiques

### ViewModels
- Utiliser des `record` pour les ViewModels
- Immuables par d√©faut (utiliser `with` pour les modifications)
- Contiennent UNIQUEMENT l'√©tat de la vue (pas de logique)

### Services de vue (ViewService)
- G√®rent l'√©tat de la vue via un ViewModel
- Contiennent la logique de pr√©sentation (filtrage, formatage, etc.)
- Font le pont entre la page et les services m√©tier
- Exposent le ViewModel via une propri√©t√© publique

### Async/Await
- **TOUJOURS** utiliser `async`/`await` pour les op√©rations IO
- Suffixe `Async` pour toutes les m√©thodes asynchrones
- Ne jamais bloquer avec `.Result` ou `.Wait()`

### Pattern matching
- Utiliser le pattern matching moderne de C#
- `switch` expressions pour la lisibilit√©

```csharp
// ‚úÖ BON
var color = type switch
{
    ShowType.Series => "#FF5722",
    ShowType.Movie => "#2196F3",
    _ => "#9e9e9e"
};
```

## üìö Documentation des features

### README.md
- Cr√©er un `README.md` dans chaque feature complexe ou r√©utilisable
- Documenter : description, param√®tres, utilisation, exemples
- Expliquer les responsabilit√©s et les d√©pendances

## üîí S√©curit√© et authentification

### Gestion des utilisateurs
- Toujours v√©rifier l'authentification avec `AuthenticationStateProvider`
- R√©cup√©rer l'ID utilisateur via les claims
- Ne jamais faire confiance aux donn√©es c√¥t√© client

```csharp
var authState = await _authStateProvider.GetAuthenticationStateAsync();
if (!authState.User.Identity?.IsAuthenticated ?? true)
{
    return null;
}
var userId = authState.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
```

## üìå R√©sum√© : Les r√®gles d'or

1. ‚úÖ **`sealed`** par d√©faut pour classes et records
2. ‚úÖ **`is` / `is not`** pour les comparaisons et tests de nullit√©
3. ‚úÖ **Vertical Slice Architecture** - tout dans Features
4. ‚úÖ **Pas de logique dans les vues** - tout dans le code-behind/services
5. ‚úÖ **Composants autonomes** - param√®tres uniquement, pas de services
6. ‚úÖ **Documentation XML** - toutes les m√©thodes publiques
7. ‚úÖ **EventCallback** - communication parent-enfant
8. ‚úÖ **Logging** - toutes les actions importantes
9. ‚úÖ **Try-catch** - gestion des erreurs partout
10. ‚úÖ **Interfaces** - pour tous les services (testabilit√©)

---

üí° **Note** : Ces r√®gles sont l√† pour garantir la maintenabilit√©, la testabilit√© et la clart√© du code. Si une r√®gle doit √™tre enfreinte pour une raison valable, documenter le pourquoi.

